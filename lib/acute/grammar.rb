# Autogenerated from a Treetop grammar. Edits may be lost.



require 'treetop'

require 'acute/nodes'
require 'acute/rules'

module Acute
  module Grammar
    include Treetop::Runtime

    def root
      @root ||= :root
    end

    def _nt_root
      start_index = index
      if node_cache[:root].has_key?(index)
        cached = node_cache[:root][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      r0 = _nt_lexemes

      node_cache[:root][start_index] = r0

      r0
    end

    def _nt_lexemes
      start_index = index
      if node_cache[:lexemes].has_key?(index)
        cached = node_cache[:lexemes][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        r1 = _nt_lexeme
        if r1
          s0 << r1
        else
          break
        end
      end
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

      node_cache[:lexemes][start_index] = r0

      r0
    end

    include Rules::ClockTimes

    include Rules::TimeZones

    include Rules::Fragments

    include Rules::GeologicalYears

    include Rules::CalendarYears

    include Rules::Seasons

    include Rules::Months

    include Rules::Dates

    include Rules::DateShifts

    include Rules::DateTimes

    include Rules::Imprecision

    def _nt_lexeme
      start_index = index
      if node_cache[:lexeme].has_key?(index)
        cached = node_cache[:lexeme][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_qualified_temporal_expression
      if r1
        r0 = r1
      else
        r2 = _nt_unparsed
        if r2
          r0 = r2
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:lexeme][start_index] = r0

      r0
    end

    def _nt_qualified_temporal_expression
      start_index = index
      if node_cache[:qualified_temporal_expression].has_key?(index)
        cached = node_cache[:qualified_temporal_expression][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_qualified_time
      if r1
        r0 = r1
      else
        r2 = _nt_qualified_fractional_shift
        if r2
          r0 = r2
        else
          r3 = _nt_qualified_shift
          if r3
            r0 = r3
          else
            r4 = _nt_qualified_date
            if r4
              r0 = r4
            else
              r5 = _nt_qualified_fractional_month
              if r5
                r0 = r5
              else
                r6 = _nt_qualified_month
                if r6
                  r0 = r6
                else
                  r7 = _nt_qualified_fractional_season
                  if r7
                    r0 = r7
                  else
                    r8 = _nt_qualified_season
                    if r8
                      r0 = r8
                    else
                      r9 = _nt_qualified_fractional_year
                      if r9
                        r0 = r9
                      else
                        r10 = _nt_geological_year
                        if r10
                          r0 = r10
                        else
                          r11 = _nt_qualified_year
                          if r11
                            r0 = r11
                          else
                            @index = i0
                            r0 = nil
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end

      node_cache[:qualified_temporal_expression][start_index] = r0

      r0
    end

    def _nt_unparsed
      start_index = index
      if node_cache[:unparsed].has_key?(index)
        cached = node_cache[:unparsed][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_morpheme
      if r1
        r0 = r1
      else
        r2 = _nt_number
        if r2
          r0 = r2
        else
          r3 = _nt_punctuation
          if r3
            r0 = r3
          else
            r4 = _nt_whitespace
            if r4
              r0 = r4
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end

      node_cache[:unparsed][start_index] = r0

      r0
    end

    module ConjunctionComma0
      def optional_hspace1
        elements[0]
      end

      def optional_hspace2
        elements[2]
      end
    end

    def _nt_conjunction_comma
      start_index = index
      if node_cache[:conjunction_comma].has_key?(index)
        cached = node_cache[:conjunction_comma][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_optional_hspace
      s0 << r1
      if r1
        if has_terminal?(",", false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(",")
          r2 = nil
        end
        s0 << r2
        if r2
          r3 = _nt_optional_hspace
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(ConjunctionComma0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:conjunction_comma][start_index] = r0

      r0
    end

    module ConjunctionOn0
      def required_hspace1
        elements[0]
      end

      def required_hspace2
        elements[2]
      end
    end

    def _nt_conjunction_on
      start_index = index
      if node_cache[:conjunction_on].has_key?(index)
        cached = node_cache[:conjunction_on][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_required_hspace
      s0 << r1
      if r1
        if has_terminal?("on", false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure("on")
          r2 = nil
        end
        s0 << r2
        if r2
          r3 = _nt_required_hspace
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(ConjunctionOn0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:conjunction_on][start_index] = r0

      r0
    end

    module ConjunctionDash0
      def optional_hspace1
        elements[0]
      end

      def optional_hspace2
        elements[2]
      end
    end

    def _nt_conjunction_dash
      start_index = index
      if node_cache[:conjunction_dash].has_key?(index)
        cached = node_cache[:conjunction_dash][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_optional_hspace
      s0 << r1
      if r1
        if has_terminal?("-", false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("-")
          r2 = nil
        end
        s0 << r2
        if r2
          r3 = _nt_optional_hspace
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(ConjunctionDash0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:conjunction_dash][start_index] = r0

      r0
    end

    module Abbreviated0
      def optional_hspace
        elements[0]
      end

    end

    def _nt_abbreviated
      start_index = index
      if node_cache[:abbreviated].has_key?(index)
        cached = node_cache[:abbreviated][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_optional_hspace
      s0 << r1
      if r1
        if has_terminal?(".", false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(".")
          r2 = nil
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Abbreviated0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:abbreviated][start_index] = r0

      r0
    end

    def _nt_space_or_dash
      start_index = index
      if node_cache[:space_or_dash].has_key?(index)
        cached = node_cache[:space_or_dash][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_conjunction_dash
      if r1
        r0 = r1
      else
        r2 = _nt_required_hspace
        if r2
          r0 = r2
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:space_or_dash][start_index] = r0

      r0
    end

    module OpenParens0
      def optional_hspace
        elements[1]
      end
    end

    def _nt_open_parens
      start_index = index
      if node_cache[:open_parens].has_key?(index)
        cached = node_cache[:open_parens][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?("(", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("(")
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_optional_hspace
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(OpenParens0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:open_parens][start_index] = r0

      r0
    end

    module CloseParens0
      def optional_hspace
        elements[0]
      end

    end

    def _nt_close_parens
      start_index = index
      if node_cache[:close_parens].has_key?(index)
        cached = node_cache[:close_parens][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_optional_hspace
      s0 << r1
      if r1
        if has_terminal?(")", false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(")")
          r2 = nil
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(CloseParens0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:close_parens][start_index] = r0

      r0
    end

    module OpenBracket0
      def optional_hspace
        elements[1]
      end
    end

    def _nt_open_bracket
      start_index = index
      if node_cache[:open_bracket].has_key?(index)
        cached = node_cache[:open_bracket][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?("[", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("[")
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_optional_hspace
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(OpenBracket0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:open_bracket][start_index] = r0

      r0
    end

    module CloseBracket0
      def optional_hspace
        elements[0]
      end

    end

    def _nt_close_bracket
      start_index = index
      if node_cache[:close_bracket].has_key?(index)
        cached = node_cache[:close_bracket][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_optional_hspace
      s0 << r1
      if r1
        if has_terminal?("]", false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("]")
          r2 = nil
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(CloseBracket0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:close_bracket][start_index] = r0

      r0
    end

    module NaturalNumber0
    end

    def _nt_natural_number
      start_index = index
      if node_cache[:natural_number].has_key?(index)
        cached = node_cache[:natural_number][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      s1, i1 = [], index
      loop do
        if has_terminal?('\G[1-9]', true, index)
          r2 = true
          @index += 1
        else
          r2 = nil
        end
        if r2
          s1 << r2
        else
          break
        end
      end
      if s1.empty?
        @index = i1
        r1 = nil
      else
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      end
      s0 << r1
      if r1
        s3, i3 = [], index
        loop do
          if has_terminal?('\G[0-9]', true, index)
            r4 = true
            @index += 1
          else
            r4 = nil
          end
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s0 << r3
      end
      if s0.last
        r0 = instantiate_node(Acute::Nodes::IntegerNode,input, i0...index, s0)
        r0.extend(NaturalNumber0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:natural_number][start_index] = r0

      r0
    end

    def _nt_number
      start_index = index
      if node_cache[:number].has_key?(index)
        cached = node_cache[:number][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        if has_terminal?('\G[0-9]', true, index)
          r1 = true
          @index += 1
        else
          r1 = nil
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      if s0.empty?
        @index = i0
        r0 = nil
      else
        r0 = instantiate_node(Acute::Nodes::IntegerNode,input, i0...index, s0)
      end

      node_cache[:number][start_index] = r0

      r0
    end

    def _nt_whitespace
      start_index = index
      if node_cache[:whitespace].has_key?(index)
        cached = node_cache[:whitespace][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        i1 = index
        s2, i2 = [], index
        loop do
          r3 = _nt_hspace
          if r3
            s2 << r3
          else
            break
          end
        end
        if s2.empty?
          @index = i2
          r2 = nil
        else
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        end
        if r2
          r1 = r2
        else
          s4, i4 = [], index
          loop do
            r5 = _nt_vspace
            if r5
              s4 << r5
            else
              break
            end
          end
          if s4.empty?
            @index = i4
            r4 = nil
          else
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          end
          if r4
            r1 = r4
          else
            @index = i1
            r1 = nil
          end
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      if s0.empty?
        @index = i0
        r0 = nil
      else
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      end

      node_cache[:whitespace][start_index] = r0

      r0
    end

    def _nt_optional_hspace
      start_index = index
      if node_cache[:optional_hspace].has_key?(index)
        cached = node_cache[:optional_hspace][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        r1 = _nt_hspace
        if r1
          s0 << r1
        else
          break
        end
      end
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

      node_cache[:optional_hspace][start_index] = r0

      r0
    end

    def _nt_required_hspace
      start_index = index
      if node_cache[:required_hspace].has_key?(index)
        cached = node_cache[:required_hspace][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        r1 = _nt_hspace
        if r1
          s0 << r1
        else
          break
        end
      end
      if s0.empty?
        @index = i0
        r0 = nil
      else
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      end

      node_cache[:required_hspace][start_index] = r0

      r0
    end

    def _nt_hspace
      start_index = index
      if node_cache[:hspace].has_key?(index)
        cached = node_cache[:hspace][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('\G[ \\t]', true, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        r0 = nil
      end

      node_cache[:hspace][start_index] = r0

      r0
    end

    def _nt_vspace
      start_index = index
      if node_cache[:vspace].has_key?(index)
        cached = node_cache[:vspace][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        if has_terminal?('\G[\\r\\n]', true, index)
          r1 = true
          @index += 1
        else
          r1 = nil
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      if s0.empty?
        @index = i0
        r0 = nil
      else
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      end

      node_cache[:vspace][start_index] = r0

      r0
    end

    def _nt_punctuation
      start_index = index
      if node_cache[:punctuation].has_key?(index)
        cached = node_cache[:punctuation][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('\G[^a-z0-9 \\t\\r\\n]', true, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        r0 = nil
      end

      node_cache[:punctuation][start_index] = r0

      r0
    end

    def _nt_morpheme
      start_index = index
      if node_cache[:morpheme].has_key?(index)
        cached = node_cache[:morpheme][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        if has_terminal?('\G[a-z]', true, index)
          r1 = true
          @index += 1
        else
          r1 = nil
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      if s0.empty?
        @index = i0
        r0 = nil
      else
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      end

      node_cache[:morpheme][start_index] = r0

      r0
    end

  end

  class GrammarParser < Treetop::Runtime::CompiledParser
    include Grammar
  end

end

