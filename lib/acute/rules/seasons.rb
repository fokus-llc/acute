# Autogenerated from a Treetop grammar. Edits may be lost.



module Acute::Rules
  module Seasons
    include Treetop::Runtime

    def root
      @root ||= :precise_fractional_season
    end

    module PreciseFractionalSeason0
      def fractional_season_node
        elements[0]
      end

      def season_year_separator
        elements[1]
      end

      def year_node
        elements[2]
      end
    end

    def _nt_precise_fractional_season
      start_index = index
      if node_cache[:precise_fractional_season].has_key?(index)
        cached = node_cache[:precise_fractional_season][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_precise_repeating_fractional_season
      s0 << r1
      if r1
        r2 = _nt_season_year_separator
        s0 << r2
        if r2
          r3 = _nt_precise_year
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Acute::Nodes::SeasonFragmentNode,input, i0...index, s0)
        r0.extend(PreciseFractionalSeason0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:precise_fractional_season][start_index] = r0

      r0
    end

    module PreciseRepeatingFractionalSeason0
      def fraction_node
        elements[0]
      end

      def repeating_season_node
        elements[1]
      end
    end

    def _nt_precise_repeating_fractional_season
      start_index = index
      if node_cache[:precise_repeating_fractional_season].has_key?(index)
        cached = node_cache[:precise_repeating_fractional_season][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_fraction
      s0 << r1
      if r1
        r2 = _nt_precise_repeating_season
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(PreciseRepeatingFractionalSeason0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:precise_repeating_fractional_season][start_index] = r0

      r0
    end

    module PreciseSeason0
      def repeating_season_node
        elements[0]
      end

      def season_year_separator
        elements[1]
      end

      def year_node
        elements[2]
      end
    end

    def _nt_precise_season
      start_index = index
      if node_cache[:precise_season].has_key?(index)
        cached = node_cache[:precise_season][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_precise_repeating_season
      s0 << r1
      if r1
        r2 = _nt_season_year_separator
        s0 << r2
        if r2
          r3 = _nt_precise_year
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Acute::Nodes::SeasonNode,input, i0...index, s0)
        r0.extend(PreciseSeason0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:precise_season][start_index] = r0

      r0
    end

    def _nt_precise_repeating_season
      start_index = index
      if node_cache[:precise_repeating_season].has_key?(index)
        cached = node_cache[:precise_repeating_season][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_repeating_hemispheric_season
      if r1
        r0 = r1
      else
        r2 = _nt_repeating_holospheric_season
        if r2
          r0 = r2
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:precise_repeating_season][start_index] = r0

      r0
    end

    module RepeatingHemisphericSeason0
      def hemisphere_node
        elements[0]
      end

      def hemisphere_season_separator
        elements[1]
      end

      def name
        elements[2]
      end
    end

    def _nt_repeating_hemispheric_season
      start_index = index
      if node_cache[:repeating_hemispheric_season].has_key?(index)
        cached = node_cache[:repeating_hemispheric_season][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_season_hemisphere
      s0 << r1
      if r1
        r2 = _nt_hemisphere_season_separator
        s0 << r2
        if r2
          r3 = _nt_repeating_season
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(RepeatingHemisphericSeason0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:repeating_hemispheric_season][start_index] = r0

      r0
    end

    module RepeatingHolosphericSeason0
      def name
        elements[0]
      end

      def hemisphere_node
        elements[1]
      end
    end

    def _nt_repeating_holospheric_season
      start_index = index
      if node_cache[:repeating_holospheric_season].has_key?(index)
        cached = node_cache[:repeating_holospheric_season][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_repeating_season
      s0 << r1
      if r1
        if has_terminal?('', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 0))
          @index += 0
        else
          terminal_parse_failure('')
          r2 = nil
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(RepeatingHolosphericSeason0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:repeating_holospheric_season][start_index] = r0

      r0
    end

    def _nt_repeating_season
      start_index = index
      if node_cache[:repeating_season].has_key?(index)
        cached = node_cache[:repeating_season][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_calendar_spring
      if r1
        r0 = r1
      else
        r2 = _nt_calendar_summer
        if r2
          r0 = r2
        else
          r3 = _nt_calendar_autumn
          if r3
            r0 = r3
          else
            r4 = _nt_calendar_winter
            if r4
              r0 = r4
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end

      node_cache[:repeating_season][start_index] = r0

      r0
    end

    def _nt_season_hemisphere
      start_index = index
      if node_cache[:season_hemisphere].has_key?(index)
        cached = node_cache[:season_hemisphere][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_northern_hemisphere
      if r1
        r0 = r1
      else
        r2 = _nt_southern_hemisphere
        if r2
          r0 = r2
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:season_hemisphere][start_index] = r0

      r0
    end

    def _nt_northern_hemisphere
      start_index = index
      if node_cache[:northern_hemisphere].has_key?(index)
        cached = node_cache[:northern_hemisphere][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_northern_hemisphere_verbose
      if r1
        r0 = r1
      else
        r2 = _nt_northern_hemisphere_terse
        if r2
          r0 = r2
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:northern_hemisphere][start_index] = r0

      r0
    end

    module NorthernHemisphereVerbose0
      def value; "northern"; end
    end

    def _nt_northern_hemisphere_verbose
      start_index = index
      if node_cache[:northern_hemisphere_verbose].has_key?(index)
        cached = node_cache[:northern_hemisphere_verbose][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?("northern", false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 8))
        r0.extend(NorthernHemisphereVerbose0)
        @index += 8
      else
        terminal_parse_failure("northern")
        r0 = nil
      end

      node_cache[:northern_hemisphere_verbose][start_index] = r0

      r0
    end

    module NorthernHemisphereTerse0
    end

    module NorthernHemisphereTerse1
      def value; "northern"; end
    end

    def _nt_northern_hemisphere_terse
      start_index = index
      if node_cache[:northern_hemisphere_terse].has_key?(index)
        cached = node_cache[:northern_hemisphere_terse][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?("n", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("n")
        r1 = nil
      end
      s0 << r1
      if r1
        r3 = _nt_abbreviated
        if r3
          r2 = r3
        else
          r2 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r2
        if r2
          if has_terminal?("h", false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("h")
            r4 = nil
          end
          s0 << r4
          if r4
            r6 = _nt_abbreviated
            if r6
              r5 = r6
            else
              r5 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r5
          end
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(NorthernHemisphereTerse0)
        r0.extend(NorthernHemisphereTerse1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:northern_hemisphere_terse][start_index] = r0

      r0
    end

    def _nt_southern_hemisphere
      start_index = index
      if node_cache[:southern_hemisphere].has_key?(index)
        cached = node_cache[:southern_hemisphere][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_southern_hemisphere_verbose
      if r1
        r0 = r1
      else
        r2 = _nt_southern_hemisphere_terse
        if r2
          r0 = r2
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:southern_hemisphere][start_index] = r0

      r0
    end

    module SouthernHemisphereVerbose0
      def value; "southern"; end
    end

    def _nt_southern_hemisphere_verbose
      start_index = index
      if node_cache[:southern_hemisphere_verbose].has_key?(index)
        cached = node_cache[:southern_hemisphere_verbose][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?("southern", false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 8))
        r0.extend(SouthernHemisphereVerbose0)
        @index += 8
      else
        terminal_parse_failure("southern")
        r0 = nil
      end

      node_cache[:southern_hemisphere_verbose][start_index] = r0

      r0
    end

    module SouthernHemisphereTerse0
    end

    module SouthernHemisphereTerse1
      def value; "southern"; end
    end

    def _nt_southern_hemisphere_terse
      start_index = index
      if node_cache[:southern_hemisphere_terse].has_key?(index)
        cached = node_cache[:southern_hemisphere_terse][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?("s", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("s")
        r1 = nil
      end
      s0 << r1
      if r1
        r3 = _nt_abbreviated
        if r3
          r2 = r3
        else
          r2 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r2
        if r2
          if has_terminal?("h", false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("h")
            r4 = nil
          end
          s0 << r4
          if r4
            r6 = _nt_abbreviated
            if r6
              r5 = r6
            else
              r5 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r5
          end
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(SouthernHemisphereTerse0)
        r0.extend(SouthernHemisphereTerse1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:southern_hemisphere_terse][start_index] = r0

      r0
    end

    module CalendarSpring0
      def value; "spring"; end
    end

    def _nt_calendar_spring
      start_index = index
      if node_cache[:calendar_spring].has_key?(index)
        cached = node_cache[:calendar_spring][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?("spring", false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 6))
        r0.extend(CalendarSpring0)
        @index += 6
      else
        terminal_parse_failure("spring")
        r0 = nil
      end

      node_cache[:calendar_spring][start_index] = r0

      r0
    end

    module CalendarSummer0
      def value; "summer"; end
    end

    def _nt_calendar_summer
      start_index = index
      if node_cache[:calendar_summer].has_key?(index)
        cached = node_cache[:calendar_summer][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?("summer", false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 6))
        r0.extend(CalendarSummer0)
        @index += 6
      else
        terminal_parse_failure("summer")
        r0 = nil
      end

      node_cache[:calendar_summer][start_index] = r0

      r0
    end

    def _nt_calendar_autumn
      start_index = index
      if node_cache[:calendar_autumn].has_key?(index)
        cached = node_cache[:calendar_autumn][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_calendar_autumn_literal
      if r1
        r0 = r1
      else
        r2 = _nt_calendar_autumn_fall
        if r2
          r0 = r2
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:calendar_autumn][start_index] = r0

      r0
    end

    module CalendarAutumnLiteral0
      def value; "autumn"; end
    end

    def _nt_calendar_autumn_literal
      start_index = index
      if node_cache[:calendar_autumn_literal].has_key?(index)
        cached = node_cache[:calendar_autumn_literal][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?("autumn", false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 6))
        r0.extend(CalendarAutumnLiteral0)
        @index += 6
      else
        terminal_parse_failure("autumn")
        r0 = nil
      end

      node_cache[:calendar_autumn_literal][start_index] = r0

      r0
    end

    module CalendarAutumnFall0
      def value; "autumn"; end
    end

    def _nt_calendar_autumn_fall
      start_index = index
      if node_cache[:calendar_autumn_fall].has_key?(index)
        cached = node_cache[:calendar_autumn_fall][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?("fall", false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 4))
        r0.extend(CalendarAutumnFall0)
        @index += 4
      else
        terminal_parse_failure("fall")
        r0 = nil
      end

      node_cache[:calendar_autumn_fall][start_index] = r0

      r0
    end

    module CalendarWinter0
      def value; "winter"; end
    end

    def _nt_calendar_winter
      start_index = index
      if node_cache[:calendar_winter].has_key?(index)
        cached = node_cache[:calendar_winter][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?("winter", false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 6))
        r0.extend(CalendarWinter0)
        @index += 6
      else
        terminal_parse_failure("winter")
        r0 = nil
      end

      node_cache[:calendar_winter][start_index] = r0

      r0
    end

    module HemisphereSeasonSeparator0
      def optional_hspace1
        elements[0]
      end

      def optional_hspace2
        elements[2]
      end
    end

    def _nt_hemisphere_season_separator
      start_index = index
      if node_cache[:hemisphere_season_separator].has_key?(index)
        cached = node_cache[:hemisphere_season_separator][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      i1, s1 = index, []
      r2 = _nt_optional_hspace
      s1 << r2
      if r2
        if has_terminal?('\G[-]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        s1 << r3
        if r3
          r4 = _nt_optional_hspace
          s1 << r4
        end
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(HemisphereSeasonSeparator0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        r5 = _nt_required_hspace
        if r5
          r0 = r5
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:hemisphere_season_separator][start_index] = r0

      r0
    end

    module SeasonYearSeparator0
      def optional_hspace1
        elements[0]
      end

      def optional_hspace2
        elements[2]
      end
    end

    def _nt_season_year_separator
      start_index = index
      if node_cache[:season_year_separator].has_key?(index)
        cached = node_cache[:season_year_separator][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      i1, s1 = index, []
      r2 = _nt_optional_hspace
      s1 << r2
      if r2
        if has_terminal?('\G[,-]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        s1 << r3
        if r3
          r4 = _nt_optional_hspace
          s1 << r4
        end
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(SeasonYearSeparator0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        r5 = _nt_required_hspace
        if r5
          r0 = r5
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:season_year_separator][start_index] = r0

      r0
    end

  end

  class SeasonsParser < Treetop::Runtime::CompiledParser
    include Seasons
  end

end

