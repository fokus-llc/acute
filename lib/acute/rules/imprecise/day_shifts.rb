# Autogenerated from a Treetop grammar. Edits may be lost.



module Acute::Rules::Imprecise
  module DayShifts
    include Treetop::Runtime

    def root
      @root ||= :qualified_fractional_shift
    end

    def _nt_qualified_fractional_shift
      start_index = index
      if node_cache[:qualified_fractional_shift].has_key?(index)
        cached = node_cache[:qualified_fractional_shift][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_precise_fractional_shift
      if r1
        r0 = r1
      else
        r2 = _nt_imprecise_fractional_shift_of_date
        if r2
          r0 = r2
        else
          r3 = _nt_imprecise_fractional_shift
          if r3
            r0 = r3
          else
            @index = i0
            r0 = nil
          end
        end
      end

      node_cache[:qualified_fractional_shift][start_index] = r0

      r0
    end

    module ImpreciseFractionalShiftOfDate0
      def fractional_shift_node
        elements[0]
      end

      def shift_date_separator
        elements[1]
      end

      def date_node
        elements[2]
      end
    end

    module ImpreciseFractionalShiftOfDate1
      def precise_fractional_shift?; false; end

      def precision; :date; end
    end

    def _nt_imprecise_fractional_shift_of_date
      start_index = index
      if node_cache[:imprecise_fractional_shift_of_date].has_key?(index)
        cached = node_cache[:imprecise_fractional_shift_of_date][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_imprecise_repeating_fractional_shift
      s0 << r1
      if r1
        r2 = _nt_shift_date_separator
        s0 << r2
        if r2
          r3 = _nt_precise_date
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Acute::Nodes::ShiftFragmentNode,input, i0...index, s0)
        r0.extend(ImpreciseFractionalShiftOfDate0)
        r0.extend(ImpreciseFractionalShiftOfDate1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:imprecise_fractional_shift_of_date][start_index] = r0

      r0
    end

    module ImpreciseFractionalShift0
      def open_parens
        elements[0]
      end

      def imprecise
        elements[1]
      end

      def close_parens
        elements[2]
      end
    end

    module ImpreciseFractionalShift1
      def fractional_shift_node; imprecise.fractional_shift_node; end
      def date_node; imprecise.date_node; end
      def precise?; false; end

      def precision; nil; end
    end

    def _nt_imprecise_fractional_shift
      start_index = index
      if node_cache[:imprecise_fractional_shift].has_key?(index)
        cached = node_cache[:imprecise_fractional_shift][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_open_parens
      s0 << r1
      if r1
        r2 = _nt_precise_fractional_shift
        s0 << r2
        if r2
          r3 = _nt_close_parens
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Acute::Nodes::ShiftFragmentNode,input, i0...index, s0)
        r0.extend(ImpreciseFractionalShift0)
        r0.extend(ImpreciseFractionalShift1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:imprecise_fractional_shift][start_index] = r0

      r0
    end

    module ImpreciseRepeatingFractionalShift0
      def open_parens
        elements[0]
      end

      def imprecise
        elements[1]
      end

      def close_parens
        elements[2]
      end
    end

    module ImpreciseRepeatingFractionalShift1
      def fraction_node; imprecise.fraction_node; end
      def repeating_shift_node; imprecise.repeating_shift_node; end
    end

    def _nt_imprecise_repeating_fractional_shift
      start_index = index
      if node_cache[:imprecise_repeating_fractional_shift].has_key?(index)
        cached = node_cache[:imprecise_repeating_fractional_shift][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_open_parens
      s0 << r1
      if r1
        r2 = _nt_precise_repeating_fractional_shift
        s0 << r2
        if r2
          r3 = _nt_close_parens
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(ImpreciseRepeatingFractionalShift0)
        r0.extend(ImpreciseRepeatingFractionalShift1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:imprecise_repeating_fractional_shift][start_index] = r0

      r0
    end

    def _nt_qualified_shift
      start_index = index
      if node_cache[:qualified_shift].has_key?(index)
        cached = node_cache[:qualified_shift][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_precise_shift
      if r1
        r0 = r1
      else
        r2 = _nt_imprecise_shift_of_date
        if r2
          r0 = r2
        else
          r3 = _nt_imprecise_shift
          if r3
            r0 = r3
          else
            @index = i0
            r0 = nil
          end
        end
      end

      node_cache[:qualified_shift][start_index] = r0

      r0
    end

    module ImpreciseShiftOfDate0
      def repeating_shift_node
        elements[0]
      end

      def shift_date_separator
        elements[1]
      end

      def date_node
        elements[2]
      end
    end

    module ImpreciseShiftOfDate1
      def precise_shift?; false; end

      def precision; :date; end
    end

    def _nt_imprecise_shift_of_date
      start_index = index
      if node_cache[:imprecise_shift_of_date].has_key?(index)
        cached = node_cache[:imprecise_shift_of_date][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_imprecise_repeating_shift
      s0 << r1
      if r1
        r2 = _nt_shift_date_separator
        s0 << r2
        if r2
          r3 = _nt_precise_date
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Acute::Nodes::ShiftNode,input, i0...index, s0)
        r0.extend(ImpreciseShiftOfDate0)
        r0.extend(ImpreciseShiftOfDate1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:imprecise_shift_of_date][start_index] = r0

      r0
    end

    module ImpreciseShift0
      def open_parens
        elements[0]
      end

      def imprecise
        elements[1]
      end

      def close_parens
        elements[2]
      end
    end

    module ImpreciseShift1
      def precise?; false; end
      def repeating_shift_node; imprecise.repeating_shift_node; end
      def date_node; imprecise.date_node; end

      def precision; nil; end
    end

    def _nt_imprecise_shift
      start_index = index
      if node_cache[:imprecise_shift].has_key?(index)
        cached = node_cache[:imprecise_shift][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_open_parens
      s0 << r1
      if r1
        r2 = _nt_precise_shift
        s0 << r2
        if r2
          r3 = _nt_close_parens
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(Acute::Nodes::ShiftNode,input, i0...index, s0)
        r0.extend(ImpreciseShift0)
        r0.extend(ImpreciseShift1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:imprecise_shift][start_index] = r0

      r0
    end

    module ImpreciseRepeatingShift0
      def open_parens
        elements[0]
      end

      def imprecise
        elements[1]
      end

      def close_parens
        elements[2]
      end
    end

    module ImpreciseRepeatingShift1
      def value; imprecise.value; end
    end

    def _nt_imprecise_repeating_shift
      start_index = index
      if node_cache[:imprecise_repeating_shift].has_key?(index)
        cached = node_cache[:imprecise_repeating_shift][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_open_parens
      s0 << r1
      if r1
        r2 = _nt_precise_repeating_shift
        s0 << r2
        if r2
          r3 = _nt_close_parens
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(ImpreciseRepeatingShift0)
        r0.extend(ImpreciseRepeatingShift1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:imprecise_repeating_shift][start_index] = r0

      r0
    end

  end

  class DayShiftsParser < Treetop::Runtime::CompiledParser
    include DayShifts
  end

end

